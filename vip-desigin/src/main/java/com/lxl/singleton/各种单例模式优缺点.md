1.私有化构造器
2.保证多线程的安全
3.延迟加载
4.防止序列化和反序列化破坏单例
5.防止反射攻击


饿汉
    优点: 没有加任何的锁、执行效率比较高；绝对线程安全
    缺点: 类加载的时候就初始化，不管用与不用都占着空间，浪费了内存
    做法:直接new、在static块中new

懒汉
    优点:省
    缺点:存在线程安全隐患，需要程序员自己解决线程问题synchronized
    做法:双重检查锁、内部类
            利用静态内部类默认不加载特性
            反射可以破坏（在其构造方法中做一些限制，一旦出现多次重复创建，则直接抛出异常。）
            
序列化
    可以破坏：解决方法 覆写readResolve()方法，实际上实例化了两次，只不过新创建的对象没有被返回而已。那如果，创建对象的动作发生频率增大，就意味着内存分配开销也就随之增大
    
注册式单例
    1.枚举：枚举对象不可能被类加载器加载多次、不能用反射来创建枚举类型原因
	序列化：枚举式单例在静态代码块中就给 INSTANCE 进行了赋值，是饿汉式单例的实现。JDK源码，ObjectInputStream 的 readObject0()方法中调用了 readEnum()方法，我们发现枚举类型其实通过类名和 Class 对象类找到一个唯一的枚举对象。因此，枚举对象不可能被类加载器加载多次。
	反射：JDK 源码，Constructor 的newInstance()方法中做了强制性的判断，如果修饰符是 odifier.ENUM 枚举类型，直接抛出异常。
    2.容器类型

ThreadLocal
    线程内安全